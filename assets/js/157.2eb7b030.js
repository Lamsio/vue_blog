(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{486:function(t,v,_){"use strict";_.r(v);var a=_(4),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h4",{attrs:{id:"线程饥饿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程饥饿"}},[t._v("#")]),t._v(" 线程饥饿")]),t._v(" "),v("h6",{attrs:{id:"发生原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发生原因"}},[t._v("#")]),t._v(" 发生原因")]),t._v(" "),v("ol",[v("li",[t._v("高优先级的线程占用了大部分的CPU时间，低优先级线程发生饥饿")]),t._v(" "),v("li",[t._v("线程被永久堵塞在一个等待进入同步块的状态")]),t._v(" "),v("li",[t._v("线程在等待一个本身也处于永久等待完成的对象")])]),t._v(" "),v("p",[t._v("当为每个线程设置优先级时，优先级越高，就能获得越高的CPU使用时间，一旦中途一直有高优先级的线程进入排队，那么最低优先级的线程将永远无法使用资源！")]),t._v(" "),v("p",[t._v("其次，Java的"),v("code",[t._v("synchronized")]),t._v("不保证线程进入语句块的顺序，如果有一个线程一直阻塞在"),v("code",[t._v("synchronized")]),t._v("语句块，将永远无法进入"),v("code",[t._v("synchronized")]),t._v("。")]),t._v(" "),v("p",[t._v("同样的，"),v("code",[t._v("notify")]),t._v("也无法保证唤醒的顺序，因此会导致某一个"),v("code",[t._v("wait")]),t._v("有可能一直陷入长期沉睡，久而久之永久饥饿！")]),t._v(" "),v("h4",{attrs:{id:"解决方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),v("p",[t._v("建议不要过于依赖"),v("code",[t._v("synchronized")]),t._v("，而应该使用自己编写的lock进行状态切换，这样可以最大程度控制锁。")])])}),[],!1,null,null,null);v.default=s.exports}}]);