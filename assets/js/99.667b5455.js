(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{428:function(l,i,v){"use strict";v.r(i);var _=v(4),t=Object(_.a)({},(function(){var l=this,i=l._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[i("h2",{attrs:{id:"物理引擎"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#物理引擎"}},[l._v("#")]),l._v(" 物理引擎")]),l._v(" "),i("p",[l._v("游戏中模仿现实情况下物体运动规则的引擎")]),l._v(" "),i("h4",{attrs:{id:"rigidbody组件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#rigidbody组件"}},[l._v("#")]),l._v(" Rigidbody组件")]),l._v(" "),i("p",[l._v("又名刚体，赋予物体现实中物理规则。但光有刚体不行，当执行游戏时，刚体物体在运动轨迹上没有受体阻拦就会一直往下坠。因此我们还需要受体才能模拟真实的物理运动情况。")]),l._v(" "),i("h6",{attrs:{id:"属性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[l._v("#")]),l._v(" 属性")]),l._v(" "),i("ul",[i("li",[l._v("Mass: 重量，游戏策划应当统一单位")]),l._v(" "),i("li",[l._v("Drag: 阻力，空气阻力，摩擦力... 通常砖头0.001，羽毛10")]),l._v(" "),i("li",[l._v("Angular Drag: 角阻力，旋转时的阻力")]),l._v(" "),i("li",[l._v("Interpolate: 用于缓解刚体运动时的抖动\n"),i("ul",[i("li",[l._v("内插值 Interpolate - 基于上一帧的变换来平滑该帧")]),l._v(" "),i("li",[l._v("外插值 Extrapolate - 基于下一帧的变化来平滑该帧")])])]),l._v(" "),i("li",[l._v("Collision Detection: 碰撞检测模式，快速移动的刚体在碰撞时有可能互相穿透，可以设置碰撞检测频率，但过高频率影响性能\n"),i("ul",[i("li",[l._v("不连续 Discrete: 不连续碰撞检测，适用于普通模式")]),l._v(" "),i("li",[l._v("连续 Continuous: 连续碰撞检测")]),l._v(" "),i("li",[l._v("动态连续 Continuous Dynamic: 连续动态碰撞检测，适用于高速物体")])])]),l._v(" "),i("li",[l._v("Constraints: 对刚体运动的约束\n"),i("ul",[i("li",[l._v("冻结位置 Freeze Position: 刚体在世界中沿所选X，Y，Z轴的移动将无效")]),l._v(" "),i("li",[l._v("冻结选择 Freeze Rotation: 刚体在世界中沿所选的X，Y，Z轴的旋转无效")])])]),l._v(" "),i("li",[l._v("IsGravity: 是否受重力影响，模拟太空可能用到")])]),l._v(" "),i("h4",{attrs:{id:"collider组件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#collider组件"}},[l._v("#")]),l._v(" Collider组件")]),l._v(" "),i("p",[l._v("又名受体，赋予物体接触刚体的能力")]),l._v(" "),i("p",[l._v("在Unity中，提供了许多Collider")]),l._v(" "),i("ul",[i("li",[l._v("Box Collider")]),l._v(" "),i("li",[l._v("Capsule Collider")]),l._v(" "),i("li",[l._v("Circle Collider 2D")]),l._v(" "),i("li",[l._v("Mesh Collider")]),l._v(" "),i("li",[l._v("Sphere Collider")]),l._v(" "),i("li",[l._v("Terrain Collider")]),l._v(" "),i("li",[l._v("Wheel Collider")])]),l._v(" "),i("p",[l._v("这些碰撞器除了形状不同，我们还需要考虑其性能，因为往往场景里会有许许多多的静态物体，而他们为了与角色产生反应，必须被赋予Collider，一旦数量庞大可能会影响性能，这点在"),i("strong",[l._v("手游")]),l._v("中尤为明显，在手游中的规则是，能用Box Collider就尽量用，可以"),i("strong",[l._v("减少性能消耗")]),l._v("。")]),l._v(" "),i("ul",[i("li",[l._v("IsTrigger：勾选后，勾选的物体将不再受到碰撞（其他物体可从他这里穿过去），物体将不再触发"),i("code",[l._v("OnCollisionXXX")]),l._v("事件，而是触发"),i("code",[l._v("OnTriggerXXX")]),l._v("事件")])]),l._v(" "),i("h4",{attrs:{id:"碰撞阶段"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#碰撞阶段"}},[l._v("#")]),l._v(" 碰撞阶段")]),l._v(" "),i("ul",[i("li",[l._v("当进入碰撞时执行（接触的第一帧）\n"),i("ul",[i("li",[i("code",[l._v("void OnCollisionEnter(Collision collOther)")])])])]),l._v(" "),i("li",[l._v("当Collider与Rigidbody碰撞时（接触时，每一帧）\n"),i("ul",[i("li",[i("code",[l._v("void OnCollisionStay(Collision collOther)")])])])]),l._v(" "),i("li",[l._v("当停止碰撞时执行（接触时的最后一帧）\n"),i("ul",[i("li",[i("code",[l._v("void OnCollisionExit(Collision collOther)")])])])])]),l._v(" "),i("h6",{attrs:{id:"补充"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[l._v("#")]),l._v(" 补充")]),l._v(" "),i("p",[l._v("上面的事件中参数Collision可以通过"),i("code",[l._v("collOther.gameObject")]),l._v("获取触碰物体的对象")]),l._v(" "),i("p",[l._v("还可以通过"),i("code",[l._v("collOther.GetContact(index)")]),l._v("获取接触点，可以用于判断受击打的部位以及溅血特效")]),l._v(" "),i("p",[l._v("有时我们想模拟子弹射击速度时，子弹往往会因为速度过快导致无法被检测，解决方案是开始时使用射线进行检测。")]),l._v(" "),i("h2",{attrs:{id:"物理材质"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#物理材质"}},[l._v("#")]),l._v(" 物理材质")])])}),[],!1,null,null,null);i.default=t.exports}}]);