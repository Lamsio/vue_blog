(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{502:function(t,a,e){"use strict";e.r(a);var o=e(4),n=Object(o.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[t._v("#")]),t._v(" 容器")]),t._v(" "),a("ol",[a("li",[t._v("创建容器")]),t._v(" "),a("li",[t._v("获取Bean")]),t._v(" "),a("li",[t._v("容器类层次结构")]),t._v(" "),a("li",[t._v("BeanFactory")])]),t._v(" "),a("h4",{attrs:{id:"获取配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取配置文件"}},[t._v("#")]),t._v(" 获取配置文件")]),t._v(" "),a("p",[t._v("先前几章中，我们通过"),a("code",[t._v('new ClassPathXmlApplicationContext("applicationContext.xml");')]),t._v("获取到配置文件对象，但当你输入该构造方法时，可以注意到，除了"),a("code",[t._v("ClassPathXmlApplicationContext")]),t._v("还有一个"),a("code",[t._v("FileSystemXmlApplicationContext")]),t._v("，其实这也能获取到配置文件对象，区别在于"),a("code",[t._v("FileSystemXmlApplicationContext")]),t._v("是根据路径获取的，而"),a("code",[t._v("ClassPathXmlApplicationContext")]),t._v("是根据类路径获取。")]),t._v(" "),a("blockquote",[a("p",[t._v("正常情况当然选择ClassPathXmlApplicationContext啦！")])]),t._v(" "),a("h4",{attrs:{id:"获取bean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取bean"}},[t._v("#")]),t._v(" 获取Bean")]),t._v(" "),a("p",[t._v("说完获取配置文件对象后，另一个就是获取Bean了。\n先前我们通过"),a("code",[t._v("getBean()")]),t._v("获取指定id的Bean对象，但每次调用这方法都得进行类型强转。")]),t._v(" "),a("p",[t._v("Spring还提供了其他两种方式")]),t._v(" "),a("ol",[a("li",[a("code",[t._v('BookDao bd = applicationContext.getBean("bookDao",BookDao.class);')])]),t._v(" "),a("li",[a("code",[t._v("BookDao bd = applicationContext.getBean(BookDao.class);")])])]),t._v(" "),a("p",[t._v("第一种只是相当于将类型转换放构造器里而已，第二种是根据类型自动装配，但问题是一旦有多个匹配的bean，就会报错！")]),t._v(" "),a("p",[t._v("![[Pasted image 20220612143643.png]]")]),t._v(" "),a("h4",{attrs:{id:"beanfactory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory"}},[t._v("#")]),t._v(" BeanFactory")]),t._v(" "),a("p",[t._v("这东西先前也没提过，其实他是ApplicationContext接口的爷接口，该接口在Spring1.0时就存在了，但由于局限性较大，后续作者又在该接口的基础上做了新的扩展，逐渐有了现在的ApplicationContext")]),t._v(" "),a("blockquote",[a("p",[t._v("小知识：在IDEA中，鼠标点击Class后按下Ctrl+H可以看到类的继承结构")])]),t._v(" "),a("p",[t._v("![[Pasted image 20220612144512.png]]\n![[Pasted image 20220612144529.png]]")])])}),[],!1,null,null,null);a.default=n.exports}}]);