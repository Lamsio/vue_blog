(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{484:function(t,e,r){"use strict";r.r(e);var n=r(4),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("下面就对"),e("a",{attrs:{href:"http://lib.csdn.net/base/javase",title:"Java SE知识库",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java"),e("OutboundLink")],1),t._v("中的垃圾回收和静态类型做一些总结：")]),t._v(" "),e("h3",{attrs:{id:"一、java中的内存分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、java中的内存分配"}},[t._v("#")]),t._v(" 一、Java中的"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("内存"),e("OutboundLink")],1),t._v("分配")]),t._v(" "),e("blockquote",[e("p",[t._v("1、stack(栈)，用于装变量和引用类型。如基本类型和引用类型的引用变量。 "),e("br"),t._v("\n2、heap(堆) ，用于装new出来的值。 "),e("br"),t._v("\n3、用来装"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("静态变量"),e("OutboundLink")],1),t._v("的区域。如static变量，字符串常量。 "),e("br"),t._v("\n4、用来装代码的区域。")])]),t._v(" "),e("h3",{attrs:{id:"二、垃圾回收时机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、垃圾回收时机"}},[t._v("#")]),t._v(" 二、"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("垃圾回收"),e("OutboundLink")],1),t._v("时机")]),t._v(" "),e("blockquote",[e("p",[t._v("1、栈上的变量一旦声明，出作用域即会被回收。 "),e("br"),t._v("\n2、堆里的对象，没有任何变量(栈上变量或静态区域的变量)指向这个对象的时候就会被回收，这个对象被标记为“垃圾对象”等待回收GC "),e("br"),t._v("\n3、GC是只回收堆空间，检查定时回收（频率由GLR决定）。 "),e("br"),t._v("\n4、调用GC.Collect();“直接”回收对象（必须等GC处理完目前的任务，才来处理该任务）。")])]),t._v(" "),e("h3",{attrs:{id:"三、静态成员的垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、静态成员的垃圾回收"}},[t._v("#")]),t._v(" 三、"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("静态成员"),e("OutboundLink")],1),t._v("的垃圾回收")]),t._v(" "),e("p",[t._v("静态成员一般也可以分为静态基本类型和静态引用类型。 "),e("br"),t._v("\n  静态基本类型存储在在静态变量区域；静态引用类型的引用存储在静态变量区域，而实例（具体内容）存储在堆上。静态成员只存在一份，静态成员加载时机：类加载的时候（第一次访问），这个类中所有静态成员就会被加载在静态存储区，同时存储在"),e("a",{attrs:{href:"http://blog.csdn.net/oTengYue/article/details/48108995#",target:"_blank",rel:"noopener noreferrer"}},[t._v("静态变量区域的成员一旦创建，直到程序退出才会被回收"),e("OutboundLink")],1),t._v("。（注：如果是引用类型，如"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("static"),e("OutboundLink")],1),t._v(" student myst=new student()，myst=null这时候，在静态存储区里面存的是一个地址（myst），这个地址指向在堆里面创建的student实例对象，当myst=null的时候，在静态存储区里面的变量会一直存在，但是在堆里面的student实例对象因为没有变量指向它，所以会被回收）。因此如果不用的静态引用类型可以通过设置=null方式让GC可以回收其堆上的空间。")]),t._v(" "),e("h3",{attrs:{id:"四、单例模式中静态成员不会被垃圾回收机制回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、单例模式中静态成员不会被垃圾回收机制回收"}},[t._v("#")]),t._v(" 四、单例模式中静态成员不会被垃圾回收机制回收")]),t._v(" "),e("p",[t._v("单例模式中静态成员的声明由于静态的机制不会被GC回收，而对应的堆上实例对象在外部无法直接设为null，所以不会被垃圾回收机制回收。当然除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的")])])}),[],!1,null,null,null);e.default=a.exports}}]);