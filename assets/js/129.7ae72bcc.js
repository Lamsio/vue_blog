(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{458:function(t,a,v){"use strict";v.r(a);var _=v(4),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"水平分割"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#水平分割"}},[t._v("#")]),t._v(" 水平分割")]),t._v(" "),a("p",[t._v("在AS内（IBGP）：水平分割机制可以确保从IBGP收到的更新不会发布给IBGP，IBGP更新只传一跳\n"),a("img",{attrs:{src:"/more/Pasted%20image%2020230115180920.png",alt:"avatar"}}),t._v("\n如上图所示，E发给A，A发给B和C，D就收不到了，但倘若希望D也能收到，该如何解决呢？")]),t._v(" "),a("p",[t._v("最简单粗暴的方法是"),a("strong",[t._v("全互联")]),t._v(" "),a("img",{attrs:{src:"/more/Pasted%20image%2020230115181132.png",alt:"avatar"}}),t._v("\n但这种方案几乎不可能使用，因为肉眼可见的复杂度增长。")]),t._v(" "),a("p",[t._v("因此，更加实用的方法是通过"),a("strong",[t._v("路由反射器")]),t._v("和"),a("strong",[t._v("联盟")]),t._v("去解决这类需求")]),t._v(" "),a("h4",{attrs:{id:"as-path"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#as-path"}},[t._v("#")]),t._v(" AS_PATH")]),t._v(" "),a("p",[t._v("这是用于AS间（EBGP）的属性，BGP更新内的重要属性，代表该路由所经过的AS号，如果接受路由器发现AS号与本地AS号一致则丢弃。\n"),a("img",{attrs:{src:"/more/Pasted%20image%2020230115181657.png",alt:"avatar"}})]),t._v(" "),a("h4",{attrs:{id:"路由聚合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由聚合"}},[t._v("#")]),t._v(" 路由聚合")]),t._v(" "),a("p",[a("img",{attrs:{src:"/more/Pasted%20image%2020230115181844.png",alt:"avatar"}})]),t._v(" "),a("blockquote",[a("p",[t._v("在执行"),a("strong",[t._v("静态聚合")]),t._v("和"),a("strong",[t._v("手动聚合")]),t._v("前，切记要先将需要聚和的路由用network宣告")])]),t._v(" "),a("p",[t._v("BGP中通过三种方式实现聚合")]),t._v(" "),a("ol",[a("li",[t._v("静态聚合 - 通过配置静态路由汇总明细路由，再用network进行宣告")]),t._v(" "),a("li",[t._v("自动聚合 - 对"),a("strong",[t._v("引入")]),t._v("的IGP路由进行"),a("strong",[t._v("主类掩码聚合")]),t._v("，而原引入的路由被抑制，不会被优选和发布给BGP邻居，通过"),a("code",[t._v("summary automatic")]),t._v("可以开启自动聚合功能")])]),t._v(" "),a("p",[t._v("假设有"),a("code",[t._v("10.1.8.0/24")]),t._v("、"),a("code",[t._v("10.1.9.0/24")]),t._v("、"),a("code",[t._v("10.1.10.0/24")]),t._v("、"),a("code",[t._v("10.1.11.0/24")]),t._v("，在开启自动聚合功能后，会统一为"),a("code",[t._v("10.0.0.0/8")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("手动聚合 - 对引入和本地路由进行聚合，最优选为手动聚合")])]),t._v(" "),a("p",[t._v("在用network宣告需要聚合的路由后，通过使用"),a("code",[t._v("aggregate [网段] [掩码]")]),t._v("指令将network宣告与之匹配的路由进行聚合，当然还能追加参数"),a("code",[t._v("detail-suppressed")]),t._v("从而抑制明细")]),t._v(" "),a("p",[t._v("手动聚合比自动聚合优先级更高，工程师应当优先使用手动聚合。")]),t._v(" "),a("h4",{attrs:{id:"环路问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#环路问题"}},[t._v("#")]),t._v(" 环路问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"/more/Pasted%20image%2020230115191122.png",alt:"avatar"}})]),t._v(" "),a("p",[t._v("假设有上述拓扑图，在AR3处有4个路由引入，但AR3并未在导出路由给AR1前做路由聚合，AR1自行做了路由聚合并生成了聚合路由"),a("code",[t._v("18.1.0.0/22")]),t._v("，但会发生一种情况，这条新的聚合路由丢失了原来的AS_PATH，这意味着AR3会学到这条路由从而形成一个环路。")]),t._v(" "),a("p",[t._v("因此，我们在进行手动聚合时，还需要追加一个"),a("code",[t._v("as-set")]),t._v("属性，用于保留原有的AS_PATH属性")])])}),[],!1,null,null,null);a.default=r.exports}}]);